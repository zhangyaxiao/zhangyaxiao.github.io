<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>设计模式总结 | 张亚晓</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="设计模式," />
  

  <meta name="description" content="设计模式总结 如何正确的使用设计模式 设计模式是为了封装变化，让各个模块可以独立变化。精准地使用设计模式的前提是你能够精准的预测需求变更的走向。我们都知道大部分人是做不到的，所以大部分人就算精通设计模式也多少会做错点什么东西。 所以说如何避免过度设计，这就要求你深入的理解你的程序所在的领域的知识，了解用户使用你的软件是为了解决什么问题，这样你预测用户的需求才会比以前更加准确，从而避免了你使用设计模">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式总结">
<meta property="og:url" content="https://zhangyaxiao.github.io/2018/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="张亚晓">
<meta property="og:description" content="设计模式总结 如何正确的使用设计模式 设计模式是为了封装变化，让各个模块可以独立变化。精准地使用设计模式的前提是你能够精准的预测需求变更的走向。我们都知道大部分人是做不到的，所以大部分人就算精通设计模式也多少会做错点什么东西。 所以说如何避免过度设计，这就要求你深入的理解你的程序所在的领域的知识，了解用户使用你的软件是为了解决什么问题，这样你预测用户的需求才会比以前更加准确，从而避免了你使用设计模">
<meta property="og:locale">
<meta property="article:published_time" content="2018-04-09T03:38:00.000Z">
<meta property="article:modified_time" content="2022-05-10T05:51:20.706Z">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
<meta name="generator" content="Hexo 5.4.2"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            笔记
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/project/"
            rel="noopener noreferrer"
            target="_blank"
            >
            项目
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-text">设计模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">如何正确的使用设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">具体设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">一.创建型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">二.结构型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">三.行为型模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">设计模式的原则</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-设计模式总结" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">设计模式总结</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.04.09</span>
      </span>

      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h1><hr>
<h2 id="如何正确的使用设计模式"><a href="#如何正确的使用设计模式" class="headerlink" title="如何正确的使用设计模式"></a>如何正确的使用设计模式</h2><blockquote>
<p>设计模式是为了封装变化，让各个模块可以独立变化。精准地使用设计模式的前提是你能够精准的预测需求变更的走向。我们都知道大部分人是做不到的，所以大部分人就算精通设计模式也多少会做错点什么东西。</p>
<p>所以说如何避免过度设计，这就要求你深入的理解你的程序所在的领域的知识，了解用户使用你的软件是为了解决什么问题，这样你预测用户的需求才会比以前更加准确，从而避免了你使用设计模式来封装一些根本不会发生的变化，也避免了你忽视了未来会发生的变化从而发现你使用的模式根本不能适应需求的新走向。</p>
<p>所以，在你满足了【知道所有设计模式为什么要被发明出来】的前提之后，剩下的其实都跟编程没关系，而跟你的领域知识和领域经验有关系。</p>
</blockquote>
<hr>
<h2 id="具体设计模式"><a href="#具体设计模式" class="headerlink" title="具体设计模式"></a>具体设计模式</h2><h3 id="一-创建型模式"><a href="#一-创建型模式" class="headerlink" title="一.创建型模式"></a>一.创建型模式</h3><ol>
<li><strong><a href="/2018/03/27/设计模式之工厂模式/">工厂方法模式</a></strong> <blockquote>
<p>我们明确地计划不同条件下创建不同实例时可以使用工厂方法模式</p>
</blockquote>
</li>
<li><strong><a href="/2018/03/27/设计模式之工厂模式/">抽象工厂方法模式</a></strong><blockquote>
<p>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。抽象工厂模式可以提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类。</p>
</blockquote>
</li>
<li><strong><a href="/2018/03/27/设计模式之单例模式/">单例模式</a></strong><blockquote>
<p>一个全局使用的对象，当你想控制实例数目，节省系统资源时，使用单例模式可以保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
</li>
<li><strong>建造者模式</strong><blockquote>
<p>当”一个复杂对象”需要创建时，建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。</p>
</blockquote>
</li>
<li><strong>原型模式</strong><blockquote>
<p>利用已有的一个原型对象，快速地生成和原型对象一样的实例</p>
</blockquote>
</li>
</ol>
<h3 id="二-结构型模式"><a href="#二-结构型模式" class="headerlink" title="二.结构型模式"></a>二.结构型模式</h3><ol>
<li><strong><a href="/2018/03/28/设计模式之适配器与外观模式/">适配器模式</a></strong><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
</li>
<li><strong><a href="/2018/03/22/设计模式之装饰模式/">装饰模式</a></strong><blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
</blockquote>
</li>
<li><strong><a href="/2018/04/02/设计模式之代理模式/">代理模式</a></strong><blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
</li>
<li><strong><a href="/2018/03/28/设计模式之适配器与外观模式/">外观模式</a></strong><blockquote>
<p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
</li>
<li><strong>桥接模式</strong><blockquote>
<p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
</blockquote>
</li>
<li><strong><a href="/2018/04/02/设计模式之迭代器和组合模式/">组合模式</a></strong><blockquote>
<p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
</li>
<li><strong>享元模式</strong><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
</li>
</ol>
<h3 id="三-行为型模式"><a href="#三-行为型模式" class="headerlink" title="三.行为型模式"></a>三.行为型模式</h3><ol>
<li><strong><a href="/2017/10/19/设计模式之策略模式/">策略模式</a></strong><blockquote>
<p>封装可以互换的行为，并使用委托决定使用哪一个 </p>
</blockquote>
</li>
<li><strong><a href="/2018/03/29/设计模式之模板方法模式/">模版方法模式</a></strong><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
</li>
<li><strong><a href="/2018/03/22/设计模式之观察者模式/">观察者模式</a></strong><blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
</li>
<li><strong><a href="/2018/04/02/设计模式之迭代器和组合模式/">迭代模式</a></strong><blockquote>
<p>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
</blockquote>
</li>
<li><strong>责任链模式</strong><blockquote>
<p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
</blockquote>
</li>
<li><strong><a href="/2018/03/28/设计模式之命令模式/">命令模式</a></strong><blockquote>
<p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
</blockquote>
</li>
<li><strong>备忘录模式</strong><blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
</li>
<li><strong><a href="/2018/04/02/设计模式之状态模式/">状态模式</a></strong><blockquote>
<p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
</blockquote>
</li>
<li><strong>访问者模式</strong><blockquote>
<p>主要将数据结构与数据操作分离。</p>
</blockquote>
</li>
<li><strong>中介模式</strong><blockquote>
<p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
</li>
<li><strong>解释器模式</strong><blockquote>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h2><ol>
<li><p><strong>单一职责原则</strong><br>不要存在多于一个导致类变更的原因，也就是说<strong>每个类应该实现单一的职责</strong>，否则就应该把类拆分。</p>
</li>
<li><p><strong>里氏替换原则</strong><br>它表示我们可以在代码中使用<strong>任意子类来替代父类并且程序不受影响</strong>，这样可以保证我们使用“继承”并没有破坏父类。<br>任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。<br>里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。  </p>
</li>
<li><p><strong>依赖倒置原则</strong><br>高层模块不应该依赖于低层模块，两者应该都依赖于抽象；抽象不依赖于细节，而细节应该依赖于抽象。这里主要是提倡“面向接口”编程，而非“面向实现”编程。<br>面向接口编程，依赖于抽象而不依赖于具体。<strong>写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</strong>  </p>
</li>
<li><p><strong>接口隔离原则</strong><br>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。<br>客户端不应该依赖于它不需要的接口，两个类之间的依赖应该建立在最小接口的基础上。<strong>这条原则的目的是为了让那些使用相同接口的类只需要实现特定必要的一组方法，而不是大量没用的方法。</strong>  </p>
</li>
<li><p><strong>迪米特法则（最少知道原则）</strong><br>一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。<br><strong>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</strong><br>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。  </p>
</li>
<li><p><strong>合成复用原则</strong><br><strong>尽量首先使用合成/聚合的方式，而不是使用继承。</strong></p>
</li>
</ol>
<hr>

    
  </div>

  
      <div class="git"></div>
  

</article>


   


<input value = sjmszj id = 'comment'  type='hidden'/>


<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
var comment = document.getElementById("comment");
if(comment){
    var gitalk = new Gitalk({
      clientID: 'fdbd91e9e1c300d143a4',
      clientSecret: '310883e14498deb1213e54acf0123bcb9cd87e06',
      repo: 'zhangyaxiao.github.io',
      owner: 'zhangyaxiao',
      admin: ['zhangyaxiao'],
      id: comment.value,
      distractionFreeMode: false
    })
    gitalk.render('gitalk-container')
}
</script>

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/04/17/%E5%85%B3%E4%BA%8E%E7%9B%91%E5%90%AC%E5%99%A8-%E8%BF%87%E6%BB%A4%E5%99%A8-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              笔记
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/project/"
              rel="noopener noreferrer"
              target="_blank"
              >
              项目
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
